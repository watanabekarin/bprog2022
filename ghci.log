GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-05-19 15:41:23.323720353
>>> 23 + 5
28
2022-05-19 15:54:15.271090846
>>> 3 + 2 * 5
13
2022-05-19 15:54:58.230271759
>>> 5 - 4 - 5
-4
2022-05-19 15:55:50.599649432
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:47.433337459
>>> double 3

<interactive>:5:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:04.705557902
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-05-26 15:02:04.776878454
>>> maxBound::Int
9223372036854775807
2022-05-26 15:03:25.556561661
>>> 2 ^ 63 - 1
9223372036854775807
2022-05-26 15:04:59.252835471
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:37.952424178
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, no modules loaded.
2022-05-26 15:49:01.344767523
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:49:01.413971249
>>> double 3
6
2022-05-26 15:56:20.888715371
>>> double (1 + 2)
6
2022-05-26 15:57:17.102348867
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-06-09 14:54:48.633572139
>>> 2 + 3 * 4
14
2022-06-09 14:58:39.363152732
>>> (2 + 3) * 4
20
2022-06-09 15:00:08.310784481
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:00:40.232567843
>>> >>>sqrt (3 ^ 2 + 4 ^ 2)

<interactive>:4:1: error: parse error on input ‘>>>’
2022-06-09 15:05:05.697525562
>>> sqrt(3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:05:53.298150223
>>> sqrt (25 :: Int)

<interactive>:6:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:10.030123258
>>> sqrt (25 :: Double)
5.0
2022-06-09 15:09:19.270114338
>>> head [1 , 3 , 4 ,]

<interactive>:8:18: error: parse error on input ‘]’
2022-06-09 15:46:37.690503009
>>> head [1 , 3 , 4]
1
2022-06-09 15:47:10.098654158
>>> hoge = [ 3 , 1 , 4 , 1 , 5] :: [INT]

<interactive>:10:33: error:
    Not in scope: type constructor or class ‘INT’
2022-06-09 15:50:33.945657198
>>> hoge - [3 , 1 , 4 , 1 , 5] :: [Int]

<interactive>:11:1: error: Variable not in scope: hoge :: [Int]
2022-06-09 15:51:12.481797657
>>> head hoge

<interactive>:12:6: error: Variable not in scope: hoge :: [a]
2022-06-09 15:51:23.293124039
>>> hoge = [3 , 1 , 4 , 1 , 5] :: [Int]
2022-06-09 15:52:21.231150634
>>> head hoge
3
2022-06-09 15:52:31.097935398
>>> tail hoge
[1,4,1,5]
2022-06-09 15:52:41.379043821
>>> hoge !! 0
3
2022-06-09 15:54:54.595651615
>>> hoge !! 2
4
2022-06-09 15:56:12.274476451
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:51.127642482
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:22.653983857
>>> hoge 5 hoge

<interactive>:20:1: error:
    • Couldn't match expected type: t0 -> [Int] -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to two value arguments,
        but its type ‘[Int]’ has none
      In the expression: hoge 5 hoge
      In an equation for ‘it’: it = hoge 5 hoge
    • Relevant bindings include it :: t (bound at <interactive>:20:1)
2022-06-09 15:58:12.836831014
>>> length head

<interactive>:21:1: error:
    • No instance for (Foldable ((->) [a0]))
        arising from a use of ‘length’
    • In the expression: length head
      In an equation for ‘it’: it = length head
2022-06-09 16:00:50.814463926
>>> length hoge
5
2022-06-09 16:01:03.36210886
>>> sum hoge
14
2022-06-09 16:01:53.738172321
>>> prodact hoge

<interactive>:24:1: error:
    • Variable not in scope: prodact :: [Int] -> t
    • Perhaps you meant ‘product’ (imported from Prelude)
2022-06-09 16:02:29.891224217
>>> product hoge
60
2022-06-09 16:02:43.187192028
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:47.660191573
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:39.488504826
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, no modules loaded.
2022-06-09 16:07:40.680640631
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:07:40.747367039
>>> double 3 + 3
9
2022-06-09 16:09:00.453436382
>>> double (3 + 3)
12
2022-06-09 16:12:08.281294685
>>> :quadruple (2 + 3)
unknown command ':quadruple'
use :? for help.
2022-06-09 16:15:48.520588819
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-06-16 15:01:22.114006498
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:16.279617732
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  quadruple :: Int -> Int
   6  quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:10:35.444395757
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:10:35.517347214
>>> 
2022-06-16 15:11:32.089506899
>>> double

<interactive>:5:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:13:00.948848674
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:04.710530954
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:36.773109748
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factrial :: integer -> integer
  10  fectrial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:9:1: error:
    The type signature for ‘factrial’ lacks an accompanying binding
      Perhaps you meant ‘fectrial’ (Defined at src/First.hs:10:1)
  |
9 | factrial :: integer -> integer
  | ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:20:48.254107565
>>> factrial 3

<interactive>:9:1: error:
    Variable not in scope: factrial :: t0 -> t
2022-06-16 15:21:55.224254073
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  fectorial n = product [1 ..10]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:9:1: error:
    The type signature for ‘factorial’ lacks an accompanying binding
      Perhaps you meant ‘fectorial’ (Defined at src/First.hs:10:1)
  |
9 | factorial :: integer -> integer
  | ^^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:23:05.272327693
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 ..10]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. 10]
      In an equation for ‘factorial’: factorial n = product [1 .. 10]
   |
10 | factorial n = product [1 ..10]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. 10’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. 10]’
      In the expression: product [1 .. 10]
      In an equation for ‘factorial’: factorial n = product [1 .. 10]
   |
10 | factorial n = product [1 ..10]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:23:34.776805421
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. n’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. n]’
      In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:24:00.629662035
>>> factorial 3

<interactive>:13:1: error:
    Variable not in scope: factorial :: t0 -> t
2022-06-16 15:24:19.875689934
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:25:35.358075248
>>> factorial 3
6
2022-06-16 15:25:46.057244106
>>> factorial 4
24
2022-06-16 15:25:56.835850927
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-06-16 15:38:30.003848335
>>> :e
No files to edit.
2022-06-16 15:40:07.92461455
>>> average [1,2,3,4,5]

<interactive>:2:1: error:
    Variable not in scope: average :: [a0] -> t
2022-06-16 15:40:34.927656896
>>> :e
No files to edit.
2022-06-16 15:41:30.022451499
>>> :e
No files to edit.
2022-06-16 15:43:06.813626261
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
Ok, no modules loaded.
2022-06-16 15:46:25.548942237
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:46:25.699558138
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:49:48.820391945
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:06:56.528135915
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:16.230612652
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:14:47.326013857
>>> myinit []
*** Exception: src/First.hs:(19,1)-(20,29): Non-exhaustive patterns in function myinit

2022-06-16 16:14:59.306030868
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-06-23 14:54:26.999077572
>>> :i Nam

<interactive>:1:1: error: Not in scope: ‘Nam’
2022-06-23 14:56:16.394208999
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:37.745583404
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-06-23 15:07:45.408823381
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 15:08:00.55320837
>>> 1 == 2
False
2022-06-23 15:08:11.063614541
>>> 'a' < 'b'
True
2022-06-23 15:11:22.289415684
>>> 'ab' < 'b'

<interactive>:4:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:12:52.479979175
>>> 1 /= 1
False
2022-06-23 15:15:42.681761729
>>> :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:25.907736718
>>> abs

<interactive>:7:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:32.571476457
>>> abs (-234)
234
2022-06-23 15:34:29.357908226
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-06-30 14:56:04.367452342
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-06-30 14:56:43.709205969
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-06-30 15:01:38.542653123
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:04:29.010250788
>>> [ x * 2 | x <- [1 .. 5] ]
[2,4,6,8,10]
2022-06-30 15:12:02.999573435
>>> [ x 'div' 2 | x <- [1 ..5] ]

<interactive>:4:5: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-06-30 15:13:27.053228301
>>>  [ x 'div' 2 | x <- [1 .. 5] ]

<interactive>:5:6: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-06-30 15:14:10.499074464
>>> [ x `div` 2 | x <- [1 .. 5] ]
[0,1,1,2,2]
2022-06-30 15:14:59.87962117
>>> [ x `divMod` 2 | x <- [1 .. 5] ]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-06-30 15:15:39.029170067
>>> [ (x, y) | x <- "abc" , y <- [4,5] ]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-06-30 15:20:50.681963833
>>>  [ (x, y) | y <- "abc" , x <- [4,5] ]
[(4,'a'),(5,'a'),(4,'b'),(5,'b'),(4,'c'),(5,'c')]
2022-06-30 15:21:28.267803162
>>>  [ (x, y) | x <- [4,5] , y <- "abc" ] ]

<interactive>:10:39: error: parse error on input ‘]’
2022-06-30 15:23:47.03865558
>>> [ (x, y) | x <- [4,5], y <- "abc" ] ]

<interactive>:11:37: error: parse error on input ‘]’
2022-06-30 15:24:42.251958459
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:12:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-06-30 15:28:39.043578211
>>> :e src/First where
catn: src/First: openFile: does not exist (No such file or directory)
2022-06-30 15:29:25.197036178
>>> :l src/First where
target ‘where’ is not a module name or a source file
2022-06-30 15:29:25.263334203
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)n  
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
Ok, no modules loaded.
2022-06-30 15:30:37.007250787
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:20:30: error: Variable not in scope: n
   |
20 | myinit (x:xs) = x : (init xs)n  
   |                              ^
Failed, no modules loaded.
2022-06-30 15:30:37.101611634
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:17:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-06-30 15:31:25.729320022
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)n  
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:20:30: error: Variable not in scope: n
   |
20 | myinit (x:xs) = x : (init xs)n  
   |                              ^
Failed, no modules loaded.
2022-06-30 15:33:03.79701576
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:20:30: error: Variable not in scope: n
   |
20 | myinit (x:xs) = x : (init xs)n  
   |                              ^
Failed, no modules loaded.
2022-06-30 15:33:03.895206521
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs) 
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:36:47.991703877
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]
[1,2,3,4,5,6,7,8,9]
2022-06-30 15:37:09.062408967
>>> [ 1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:47:30.742790873
>>> mylength [`a` .. `z`]

<interactive>:23:15: error: parse error on input ‘..’
2022-06-30 15:51:08.165490407
>>> mylength ['a' .. 'z']

<interactive>:24:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-06-30 15:52:26.129827779
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs) 
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs ]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:54:43.872996665
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:54:43.972449578
>>>  mylength ['a' .. 'z']
26
2022-06-30 15:55:11.666617779
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-07-07 16:04:38.325860008
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, no modules loaded.
2022-07-07 16:05:04.47915814
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:05:04.561180592
>>> old 'A'

<interactive>:3:1: error:
    • Variable not in scope: old :: Char -> t
    • Perhaps you meant one of these:
        ‘ord’ (imported from Data.Char), ‘odd’ (imported from Prelude)
2022-07-07 16:05:25.575740829
>>> ord 'A'
65
2022-07-07 16:05:54.634014759
>>> ord 'a'
97
2022-07-07 16:06:08.370895736
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-07-14 15:10:54.375466113
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c 
Ok, no modules loaded.
2022-07-14 15:11:21.104360084
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:11:21.184161221
>>> let2int 'a'
97
2022-07-14 15:12:16.382510411
>>> let2int 'z'
122
2022-07-14 15:13:00.561733515
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c 
   7  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:7:1: warning: [-Woverlapping-patterns]
    Pattern match is redundant
    In an equation for ‘let2int’: let2int c = ...
  |
7 | let2int c = ord c - ord 'a'
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
Ok, one module loaded.
2022-07-14 15:14:57.928160057
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:39.405008406
>>> let2int 'z'
25
2022-07-14 15:15:56.75377002
>>> ord 'a'
97
2022-07-14 15:19:02.937835529
>>> chr 97
'a'
2022-07-14 15:19:19.32357033
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:19:50.623772072
>>> int2let 0
'a'
2022-07-14 15:20:01.802830386
>>> int2let 25
'z'
2022-07-14 15:20:15.923839242
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:14:15: error: parse error on input ‘=’
   |
14 |     otherwise = c
   |               ^
Failed, no modules loaded.
2022-07-14 15:27:16.214991409
>>> shift 3 'a'

<interactive>:14:1: error:
    Variable not in scope: shift :: t0 -> Char -> t
2022-07-14 15:27:33.535310381
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:27:54.785988004
>>> shift 3 'a'
'd'
2022-07-14 15:28:14.972663653
>>> shift (-3) 'd'
'a'
2022-07-14 15:28:36.912984264
>>> shift 3 'z'
'c'
2022-07-14 15:29:27.417229228
>>> shift 3

<interactive>:19:1: error:
    • No instance for (Show (Char -> Char))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-14 15:29:41.673269631
>>> shift 3 ' '
' '
2022-07-14 15:32:30.028015571
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:35:31.33012161
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:36:12.157076338
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:47:36.269894727
>>> it
"kdvnhoo lv ixq"
2022-07-14 15:48:00.760382405
>>> encode (-3) it
"haskell is fun"
2022-07-14 15:48:51.707530063
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:58:50.248160294
>>> length table
26
2022-07-14 15:59:36.492453103
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:07:49.208593614
>>> percent 5 15
33.333336
2022-07-14 16:08:43.599023298
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:14:07.394296482
>>> count 's' "Mississippi"
4
2022-07-14 16:14:42.22744712
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/karin/bprog2022/.ghci
2022-07-21 15:05:43.348953339
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = lowers xs
Ok, no modules loaded.
2022-07-21 15:06:07.924670902
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:33:14: error:
    Variable not in scope: lowers :: String -> t
   |
33 |          n = lowers xs
   |              ^^^^^^
Failed, no modules loaded.
2022-07-21 15:06:08.063149155
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:07:22.948210424
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:19:00.13088129
>>> length sample
15
2022-07-21 15:19:31.81022041
>>> sample
"abbcccddddeeeee"
2022-07-21 15:19:39.353667406
>>> freqs sample
[6.666667,13.333334,20.0,26.666668,33.333336,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
2022-07-21 15:20:02.296744994
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
  37  
  38  chisqr :: [Float] -> [Float] -> Float
  39  chisqr os es =sum [((o-e)^2)/e | (o,e) <- zip os es]
  40  
  41  rotate :: Int -> [a] -> [a]
  42  rotate n xs = drop n xs ++ take n xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:38:29.611575313
>>> rotate 3 [1,2,3,4,5]
[4,5,1,2,3]
2022-07-21 15:39:40.270981628
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
  37  
  38  chisqr :: [Float] -> [Float] -> Float
  39  chisqr os es =sum [((o-e)^2)/e | (o,e) <- zip os es]
  40  
  41  rotate :: Int -> [a] -> [a]
  42  rotate n xs = drop n xs ++ take n xs
  43  
  44  table' :: [Float]
  45  table' = freqs "kdvnhoo lv ixq"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:45:51.436068648
>>> table'
[0.0,0.0,0.0,7.1428576,0.0,0.0,0.0,7.1428576,7.1428576,0.0,7.1428576,7.1428576,0.0,7.1428576,14.285715,0.0,7.1428576,0.0,0.0,0.0,0.0,14.285715,0.0,7.1428576,0.0,0.0]
2022-07-21 15:46:03.224575914
>>> [chisqr (rotate n table') | n <- [0..25] ]

<interactive>:12:1: error:
    • No instance for (Show ([Float] -> Float))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-21 15:47:43.076235477
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
  37  
  38  chisqr :: [Float] -> [Float] -> Float
  39  chisqr os es =sum [((o-e)^2)/e | (o,e) <- zip os es]
  40  
  41  rotate :: Int -> [a] -> [a]
  42  rotate n xs = drop n xs ++ take n xs
  43  
  44  table' :: [Float]
  45  table' = freqs sampleAngou
  46  
  47  sampleAngou :: String
  48  sampleAngou = "kdvnhoo lv itq"
  49  
  50  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:49:45.864697427
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
  37  
  38  chisqr :: [Float] -> [Float] -> Float
  39  chisqr os es =sum [((o-e)^2)/e | (o,e) <- zip os es]
  40  
  41  rotate :: Int -> [a] -> [a]
  42  rotate n xs = drop n xs ++ take n xs
  43  
  44  table' :: [Float]
  45  table' = freqs sampleAngou
  46  
  47  sampleAngou :: String
  48  sampleAngou = "kdvnhoo lv itq"
  49  
  50  crack :: String -> String
  51  crack xs = encode (-factor) xs
  52      where
  53          factor = head (positions (minimum chitab) chitab)
  54          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  55          table' = freqs xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:53:24: error:
    Variable not in scope: positions :: Float -> [Float] -> [a]
   |
53 |         factor = head (positions (minimum chitab) chitab)
   |                        ^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:54:18.52390618
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
  37  
  38  chisqr :: [Float] -> [Float] -> Float
  39  chisqr os es =sum [((o-e)^2)/e | (o,e) <- zip os es]
  40  
  41  rotate :: Int -> [a] -> [a]
  42  rotate n xs = drop n xs ++ take n xs
  43  
  44  table' :: [Float]
  45  table' = freqs sampleAngou
  46  
  47  sampleAngou :: String
  48  sampleAngou = "kdvnhoo lv itq"
  49  
  50  crack :: String -> String
  51  crack xs = encode (-factor) xs
  52      where
  53          factor = head (positions (minimum chitab) chitab)
  54          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  55          table' = freqs xs
  56  
  57  positions :: Eq a => a -> [a] -> [Int]
  58  positions x xs = [ i | (x', i) <- zip xs [0 ..]]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:58:10.246744193
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
  37  
  38  chisqr :: [Float] -> [Float] -> Float
  39  chisqr os es =sum [((o-e)^2)/e | (o,e) <- zip os es]
  40  
  41  rotate :: Int -> [a] -> [a]
  42  rotate n xs = drop n xs ++ take n xs
  43  
  44  table' :: [Float]
  45  table' = freqs sampleAngou
  46  
  47  sampleAngou :: String
  48  sampleAngou = "kdvnhoo lv itq"
  49  
  50  crack :: String -> String
  51  crack xs = encode (-factor) xs
  52      where
  53          factor = head (positions (minimum chitab) chitab)
  54          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  55          table' = freqs xs
  56  
  57  positions :: Eq a => a -> [a] -> [Int]
  58  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:59:53.920348384
>>> positions False [True, False, True, False]
[1,3]
2022-07-21 16:00:47.891018734
>>> crack sampluAngou

<interactive>:18:7: error:
    • Variable not in scope: sampluAngou :: String
    • Perhaps you meant ‘sampleAngou’ (line 48)
2022-07-21 16:03:09.68171818
>>> crack sampleAngou
"dwogahh eo bmj"
2022-07-21 16:04:07.496820723
>>> positions False [True, False, True, False]
[1,3]
2022-07-21 16:06:16.255601624
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let ::  Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String )  
  17  encode n xs = [shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0,
  21           0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0,
  22           6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1 ]
  23  
  24  percent :: Int -> Int -> Float
  25  percent n m = (fromIntegral n / fromIntegral m) * 100
  26  
  27  count :: Char -> (String -> Int)
  28  count x xs = length [ x' | x' <- xs, x == x']
  29  
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32       where 
  33           n = length xs
  34  
  35  sample :: String
  36  sample = "abbcccddddeeeee"
  37  
  38  chisqr :: [Float] -> [Float] -> Float
  39  chisqr os es =sum [((o-e)^2)/e | (o,e) <- zip os es]
  40  
  41  rotate :: Int -> [a] -> [a]
  42  rotate n xs = drop n xs ++ take n xs
  43  
  44  table' :: [Float]
  45  table' = freqs sampleAngou
  46  
  47  sampleAngou :: String
  48  sampleAngou = "kdvnhoo lv ixq"
  49  
  50  crack :: String -> String
  51  crack xs = encode (-factor) xs
  52      where
  53          factor = head (positions (minimum chitab) chitab)
  54          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  55          table' = freqs xs
  56  
  57  positions :: Eq a => a -> [a] -> [Int]
  58  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
  59  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 16:08:09.978777982
>>> crack sampleAngou
"haskell is fun"
2022-07-21 16:08:21.048429281
>>> :q
Leaving GHCi.
